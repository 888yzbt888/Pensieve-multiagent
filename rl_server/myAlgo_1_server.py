"""
post_data:lastRequest(the order number of last chunk)
	  lastquality(0-5,0 is the lowest quality)
	  lastChunkSize(bit,kb/1024)
	  lastChunkStartTime(ms from 1970.1.1) 
	  lastChunkFinishTime(ms from 1970.1.1) 
	  buffer(s)
	  bufferAdjust(buffer time except the chunk played now)
	  RebufferTime(s)
	  bandwidthEst(kb/s)

	  type(???)
	  pastThroughput
	  heartbeat

input_dict:'log_file'
           'last_bit_rate'
           'last_total_rebuf'
           'video_chunk_coount'
           's_batch'

"""
#!/usr/bin/env python
import multiprocessing
import time
import copy
import socket
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
import SocketServer
import base64
import urllib
import sys
import os
import json
import time
import fcntl
import matplotlib.pyplot as plt
os.environ['CUDA_VISIBLE_DEVICES']=''

import numpy as np
import time
import itertools

################## ROBUST MPC ###################

S_INFO = 5  # bit_rate, buffer_size, rebuffering_time, bandwidth_measurement, chunk_til_video_end
S_LEN = 8  # take how many frames in the past
MPC_FUTURE_CHUNK_COUNT = 5
VIDEO_BIT_RATE = [300,750,1200,1850,2850,4300]  # Kbps
BITRATE_REWARD = [1, 2, 3, 12, 15, 20]
BITRATE_REWARD_MAP = {0: 0, 300: 1, 750: 2, 1200: 3, 1850: 12, 2850: 15, 4300: 20}
M_IN_K = 1000.0
BUFFER_NORM_FACTOR = 10.0
CHUNK_TIL_VIDEO_END_CAP = 48.0
TOTAL_VIDEO_CHUNKS = 448
DEFAULT_QUALITY = 0  # default video quality without agent
REBUF_PENALTY = 4.3  # 1 sec rebuffering -> this number of Mbps
SMOOTH_PENALTY = 1
TRAIN_SEQ_LEN = 100  # take as a train batch
MODEL_SAVE_INTERVAL = 100
RANDOM_SEED = 42
RAND_RANGE = 1000
SUMMARY_DIR = './results'
LOG_FILE = './results/log'
# in format of time_stamp bit_rate buffer_size rebuffer_time video_chunk_size download_time reward
NN_MODEL = None

CHUNK_COMBO_OPTIONS = []

# past errors in bandwidth
past_errors = []
past_bandwidth_ests = []

################################
#multiprocessing share variables
manager=multiprocessing.Manager()
Que1=manager.list()
Que2=manager.list()
Dict1=manager.dict()
Dict2=manager.dict()
begin_time=time.time()
QueOnline=manager.list()
DictOnline={}#remember last quality for each IP 
MultiClientState={}# format:{"IP":[(int)heartbeat_time_not_request_time,(int)quality]}
################################

# video chunk sizes
'''
size_video1 = [2354772, 2123065, 2177073, 2160877, 2233056, 1941625, 2157535, 2290172, 2055469, 2169201, 2173522, 2102452, 2209463, 2275376, 2005399, 2152483, 2289689, 2059512, 2220726, 2156729, 2039773, 2176469, 2221506, 2044075, 2186790, 2105231, 2395588, 1972048, 2134614, 2164140, 2113193, 2147852, 2191074, 2286761, 2307787, 2143948, 1919781, 2147467, 2133870, 2146120, 2108491, 2184571, 2121928, 2219102, 2124950, 2246506, 1961140, 2155012, 1433658]
size_video2 = [1728879, 1431809, 1300868, 1520281, 1472558, 1224260, 1388403, 1638769, 1348011, 1429765, 1354548, 1519951, 1422919, 1578343, 1231445, 1471065, 1491626, 1358801, 1537156, 1336050, 1415116, 1468126, 1505760, 1323990, 1383735, 1480464, 1547572, 1141971, 1498470, 1561263, 1341201, 1497683, 1358081, 1587293, 1492672, 1439896, 1139291, 1499009, 1427478, 1402287, 1339500, 1527299, 1343002, 1587250, 1464921, 1483527, 1231456, 1364537, 889412]
size_video3 = [1034108, 957685, 877771, 933276, 996749, 801058, 905515, 1060487, 852833, 913888, 939819, 917428, 946851, 1036454, 821631, 923170, 966699, 885714, 987708, 923755, 891604, 955231, 968026, 874175, 897976, 905935, 1076599, 758197, 972798, 975811, 873429, 954453, 885062, 1035329, 1026056, 943942, 728962, 938587, 908665, 930577, 858450, 1025005, 886255, 973972, 958994, 982064, 830730, 846370, 598850]
size_video4 = [668286, 611087, 571051, 617681, 652874, 520315, 561791, 709534, 584846, 560821, 607410, 594078, 624282, 687371, 526950, 587876, 617242, 581493, 639204, 586839, 601738, 616206, 656471, 536667, 587236, 590335, 696376, 487160, 622896, 641447, 570392, 620283, 584349, 670129, 690253, 598727, 487812, 575591, 605884, 587506, 566904, 641452, 599477, 634861, 630203, 638661, 538612, 550906, 391450]
size_video5 = [450283, 398865, 350812, 382355, 411561, 318564, 352642, 437162, 374758, 362795, 353220, 405134, 386351, 434409, 337059, 366214, 360831, 372963, 405596, 350713, 386472, 399894, 401853, 343800, 359903, 379700, 425781, 277716, 400396, 400508, 358218, 400322, 369834, 412837, 401088, 365161, 321064, 361565, 378327, 390680, 345516, 384505, 372093, 438281, 398987, 393804, 331053, 314107, 255954]
size_video6 = [181801, 155580, 139857, 155432, 163442, 126289, 153295, 173849, 150710, 139105, 141840, 156148, 160746, 179801, 140051, 138313, 143509, 150616, 165384, 140881, 157671, 157812, 163927, 137654, 146754, 153938, 181901, 111155, 153605, 149029, 157421, 157488, 143881, 163444, 179328, 159914, 131610, 124011, 144254, 149991, 147968, 161857, 145210, 172312, 167025, 160064, 137507, 118421, 112270]
'''
size_video1=[1756806,3091206,2210154,1845731,1817275,2069902,2117640,2061264,2237179,2132441,2044975,3789197,3250223,2487213,2149619,1765477,
2505293,2673223,2084351,2069989,1855189,2478422,2580412,2065841,2585352,1351167,1398486,1725385,2897186,4738096,1670320,1756062,
3048206,4866144,1843384,1584205,1884317,1858789,1038538,798577,2117675,2528940,1398909,3205655,2983891,2201743,2366969,2553838,
1501437,1267022,1644497,1367567,1203298,3427696,1968656,3096706,2066317,2634682,1694746,1434945,3173242,1693021,1682424,2113373,
3103217,2462552,2256905,2226073,1980055,2037901,2470135,2128194,2434345,1714265,1330462,2102803,1015863,865084,1634635,1229781,
1227461,1383375,1572941,1624467,1260343,2100804,1782111,3028204,1845902,1283138,1529032,1782594,1613129,1621860,1702228,1935782,
1908470,1820040,1542276,2025509,1672002,1681633,3771816,5057431,3537995,2803543,3831917,2709325,3627028,2349666,2466424,2215131,
2249004,1704399,1689433,1362005,1565350,2242939,2378241,2021904,2019269,1054954,2328052,2211591,2104177,2280895,1991117,1857563,
2209717,1711273,1293338,1289551,1976534,2284536,1925431,2869117,2469558,1435620,1240014,1811217,2988838,2552354,2365918,2065200,
2555376,1779921,2281000,2856816,2252510,1331370,1565606,1548717,3429310,1957226,1744946,1736383,2170169,2128049,2573352,2262965,
2877128,2632416,2110319,2309152,2087447,2303868,3110829,4470951,4276187,2646215,2596715,1701057,2932345,2622505,2362883,2360631,
3172401,3599259,2951048,1968506,2345232,1739989,1303134,1273197,1463247,1841675,2594747,3307177,1289034,2849319,2067334,1658999,
1451249,2074198,1510216,2665640,2975156,1903333,3534501,4269578,4256969,4212087,983135,527732,391690,1403108,1438881,1452557,
1917879,1613934,1871217,1188694,2512090,2858958,1531701,1008854,1003379,1815850,1586467,980482,1439500,2289989,2449550,3404941,
3365845,2830877,4573090,2648680,4028108,5273438,3649905,3386154,2446726,2965108,2245612,1832510,2071735,1755973,2019058,1360561,
1039489,1894295,1999107,1666014,2242594,1746466,2870885,2284279,1714119,2282746,1999381,2436148,1828361,2833893,2132959,1585105,
2275927,2131090,2951419,2197713,2049883,1657043,2195265,2978021,2007940,1712613,1729774,1533013,3056849,3034214,3327704,3120601,
2265234,1983515,2468537,2171814,1750435,1885298,2056222,2409637,1384308,1073859,1993041,2524543,2684433,2749667,1487433,2299203,
1711371,1882897,1979814,2600016,2829907,2024223,2435121,1745680,1733204,2311748,2360093,2962846,2530685,2333345,2573975,2688803,
1674837,2328829,2654846,2177220,1983637,1826992,1554600,1742047,1015182,1327517,1392909,1997961,2777906,2151277,1385355,1841831,
2576036,2248077,1670266,1921688,2513568,2592109,1866077,2254994,3076104,2892882,2637278,2258700,1223635,905654,900966,532695,
678430,1684441,1272715,1174559,1071726,1261171,1574531,1726304,1393375,1612197,1577541,1178594,1331352,1471475,1258708,1417142,
1337069,1753784,3098761,1712958,1487216,1749591,2094655,1655374,1838915,1632130,4455112,1103313,4325538,4260027,3363232,1966800,
2387229,2734086,2389536,2457011,2795839,2917015,2516264,2127460,2593348,3241121,3966814,3003788,1984507,2589085,2196063,1610600,
1378770,2396778,1976157,1717434,669393,1027820,1375132,1464032,1326640,1729066,1534541,1787945,2596315,3393474,2786962,3161567,
2753054,2801599,3086005,2440861,3156653,4016406,3399126,3785131,4186971,3408842,2612351,2792930,2184320,1364863,1291497,958698,
1640227,1815859,1795500,2069010,2016002,1406199,1373710,1718790,980021,862871,990244,1247321,1934872,1727416,1281950,1283997,
2167162,1437622,911988,1208836,1855819,1746139,2142901,3077141,2097075,1667617,2375729,1176383,1534788,2019092,1649060,1119606,
2066820]
size_video2=[1248166,1909948,1437354,1206293,1202036,1374260,1394562,1352039,1499553,1420399,1360662,2352325,2206383,1618768,
1455386,1204706,1713574,1864652,1448970,1398569,1293903,1662378,1778570,1405415,1767145,754576,789631,1047145,1830919,3283497,
1110502,1143921,2082236,3252018,1219923,1071692,1295207,1266141,656576,503078,1354183,1699087,927720,2208172,2011759,1494987,
1602807,1716281,996382,808047,975928,884332,755695,2258444,1301747,2091230,1441438,1791927,1142314,948784,2118602,1134808,1088077,
1419506,2094634,1666971,1573121,1445975,1315146,1393944,1676874,1438847,1587400,1082750,855365,1309596,616101,522811,1009092,
755328,744447,856311,990560,994122,741287,1350804,1149553,2095051,1184299,762583,968586,1179001,1003173,998496,1057590,1243591,
1237504,1117387,937314,1261624,1166183,1171457,2696482,3460711,2432287,1831251,2639863,1888769,2576440,1610171,1708230,1492094,
1538209,1132001,1123038,874553,1004636,1426699,1544177,1349606,1360880,645082,1354293,1398892,1451433,1504901,1328553,1263252,
1509891,1153670,855640,864167,1392355,1511324,1301036,1948238,1647259,955411,816968,1185012,2007860,1648783,1522896,1335718,
1707248,1085428,1457959,1994052,1475727,828972,948348,933982,2382507,1225258,1097507,1118835,1448416,1390061,1695141,1496810,
1954410,1774003,1366911,1524592,1368957,1501570,2095420,3114760,2838416,1502515,1694876,1053663,2100929,1903225,1667629,1663218,
2248474,2551140,2051397,1347603,1626107,1164880,871909,857484,973494,1264289,1741906,2304449,845899,1950152,1361535,1096620,
956379,1374366,979791,1713882,1980346,1253742,2331705,2782848,2771738,2807548,644361,352430,247261,924748,983983,978337,1273457,
1072491,1233180,753303,1719760,1976297,1020941,643472,632199,1212648,1033471,622503,954344,1418860,1581120,2280953,2273723,
1722839,3004290,1786110,2762113,3508086,2471169,2290623,1631933,2022588,1501694,1221686,1392053,1162530,1350142,916630,692591,
1272848,1376995,1130650,1511110,1188451,1956043,1553905,1190117,1536041,1334153,1620445,1229638,1904189,1437879,1043343,1484736,
1389038,1962114,1379569,1348907,1083199,1464620,1986660,1331590,1086919,1129684,1020726,2049670,2077307,2244912,2092287,1502555,
1329093,1638317,1432601,1186820,1259056,1378272,1592067,894118,702494,1328338,1707818,1858005,1814721,965118,1491287,1130946,
1245095,1297373,1761282,1887826,1337368,1614799,1121034,1145238,1497043,1606601,2025110,1710529,1583480,1723662,1810776,1113208,
1547386,1774950,1421925,1206322,1187183,1004007,1147471,676151,894621,880733,1266385,1848743,1457129,887321,1185256,1683346,
1454053,1091702,1298560,1702106,1712364,1162421,1518078,2105991,1963481,1783520,1462072,721990,579786,589643,344866,427515,
1117244,806288,741042,675112,787869,1011434,1126209,885267,1055611,1018506,773227,870077,912214,776772,883886,862865,1150468,
2067548,1099289,945530,1150026,1362064,1050127,1197301,1075450,2836687,702922,2875327,2778004,2245324,1287876,1575207,1779274,
1563888,1703575,1879597,1981220,1706876,1336949,1679947,2160617,2693480,2009306,1332161,1758489,1457012,1054975,926778,1589787,
1315164,1139932,406770,664625,936523,928176,835472,1167407,994739,1185573,1740000,2319760,1837859,2103152,1854032,1873751,2125146,
1614715,2116308,2777412,2292582,2515009,2837060,2395144,1790486,1913686,1448776,902340,828891,617586,1081453,1195033,1179707,
1339413,1300244,935908,880962,1098413,618451,537171,620261,773863,1240249,1093356,802481,790748,1415323,837047,545014,773276,
1225405,1133886,1437142,2045825,1351366,1027020,1495764,704275,989618,1287214,1087634,718747,1318691]
size_video3=[846285,1168830,924155,782361,776921,896171,904410,867529,987852,931970,884019,1388977,1386547,1061921,985293,802234,
1169255,1286193,995130,938950,889120,1097258,1199443,945496,1179962,430164,436726,624519,1113671,2138958,731588,732163,1371730,
2110792,788301,712212,865112,846544,419881,323168,854227,1103578,603737,1462476,1328702,995325,1062304,1130531,658362,515203,
564263,576357,481669,1439148,831514,1345162,986175,1206557,761735,621067,1371358,739751,691765,948480,1381127,1093177,1075045,
921199,858138,939164,1113522,952278,1002220,678313,545154,794368,368560,322602,627633,465516,454419,527661,617205,601121,418400,
838302,720424,1421671,743692,444613,590983,767637,605102,586040,629895,773906,770305,679673,553179,767895,798336,717269,1749944,
2232941,1630935,1191422,1750938,1335785,1831757,1108036,1190875,1006044,1040709,746704,736186,559337,646623,884342,996032,902282,
898520,388061,706020,837590,997771,984903,869629,841845,1003621,765322,549112,567129,962434,983686,849944,1297068,1068550,630926,
534534,753751,1297143,1033674,972729,860044,1146757,643290,916479,1371688,950221,503853,565079,558122,1579179,764904,684818,714375,
958026,897292,1095530,976392,1284670,1157384,849960,983202,885117,949242,1378747,2093615,1794015,892920,1070196,636000,1427417,
1358293,1161687,1148764,1556485,1755196,1391857,901239,1101441,767029,575457,571960,640246,852139,1153342,1551623,552146,1303983,
884697,728329,631483,890909,629541,1057592,1264644,812359,1495774,1802682,1794299,1809999,421592,234510,162002,598631,660455,
650412,831883,704816,796782,469916,1141450,1332339,673944,405808,393579,790772,668101,391316,620897,855778,987162,1437210,1494618,
1000189,1977624,1160710,1853267,2272158,1620476,1512714,1065616,1349832,985649,800298,916009,747151,878787,611733,458891,824552,
936781,763908,1005463,805397,1309198,1027202,824776,1018133,878999,1059264,816116,1245755,950480,675165,934743,881605,1262539,
836769,868241,689535,960324,1290799,875221,677750,719309,673009,1332185,1381609,1467929,1364835,972063,879023,1062308,925128,
796868,822789,917077,1038227,572879,460030,870647,1135715,1267450,1170787,608866,932475,718075,794316,835131,1173614,1226376,
873792,1039123,698256,744176,962960,1076340,1357311,1134278,1063750,1129502,1193512,731147,1008405,1172782,916351,714909,746975,
628955,733798,452985,599131,547008,788141,1187992,947166,556402,745185,1072325,919245,703608,867170,1130427,1110818,720520,1007762,
1397415,1311440,1185457,919927,415043,381670,384138,221070,272611,721164,508382,463087,418721,476494,636457,721220,555097,676089,
633209,496792,565895,553631,472079,531680,549381,738800,1333841,682133,579828,733952,859037,656064,756593,693793,1828137,431863,
1810452,1836670,1447052,837477,1007940,1130632,997037,1164277,1231827,1316193,1135411,817342,1051188,1391898,1762282,1306967,
877949,1172156,944666,677181,614653,1029902,861520,751279,251924,434194,637408,585673,517743,779377,624265,767662,1141932,1552512,
1182714,1350835,1216575,1221492,1437167,1047801,1352884,1866550,1498852,1594916,1933364,1666636,1216493,1299406,946556,587152,
523357,398282,698490,768546,747186,839672,816283,609526,551500,685818,385510,332617,384081,472836,784876,681576,495325,478054,
910864,486727,327909,490384,787676,714464,934579,1322102,836378,608941,898288,419176,631361,777189,710660,463377,848825]
size_video4=[547035,706404,596043,524098,504228,582524,590858,552807,649725,609806,581924,835167,856359,720885,648993,549888,798544,
890208,680375,621228,612247,714936,801526,636640,781633,258480,256981,381833,668878,1316285,483083,470324,887319,1346096,488576,
476883,574255,560775,275294,213942,544631,721930,394905,956401,866807,668112,707053,752293,439005,328990,332676,381240,315599,
905000,536920,856841,676222,814761,511744,406110,872426,478738,441067,638082,902857,705191,735017,597647,564153,640146,744700,
634426,622405,429916,348023,473333,223233,207060,398798,297699,289124,338019,386894,376068,247323,529278,458771,954008,469848,
268451,367008,510493,384351,336696,365757,469230,466878,397890,306208,392038,480889,427503,1061331,1462570,1107397,788212,1201905,
958934,1296354,764232,834022,684159,703462,494688,476757,358278,421053,547982,651712,605673,604769,247633,362988,500301,679289,
636811,569262,554524,657393,500344,353603,370888,654913,640820,555403,854536,682544,425652,353977,482904,831613,646249,623250,
570778,781138,395629,591756,919672,608636,315279,348908,341251,1028395,493213,433388,461614,633669,582445,710571,635445,829185,
740760,520948,625161,572429,587024,885619,1366909,1096009,549068,693014,384613,967739,961765,802806,786390,1063204,1193221,938432,
594814,738128,514183,385394,386211,419937,569630,759702,1035614,363332,867267,584199,495296,418710,579747,407271,643695,793432,
532780,953519,1181184,1173164,1150240,278260,158326,109243,391560,447495,432372,541903,462974,514903,297437,746687,889772,446977,
261064,245091,514842,433432,248997,401709,510992,623671,875583,954252,565854,1282428,760254,1230934,1471145,1041466,1007408,
700685,908906,647372,531923,604648,480567,571680,415481,311725,528791,648577,526915,676767,544984,877852,681274,584479,682400,
587249,697584,541523,819236,635454,439248,575534,558134,795960,507237,560309,435884,630696,842280,584377,418701,452008,447495,
855620,910486,955619,874290,634816,588917,688253,601008,545601,546370,622967,696809,377403,307085,582646,767567,881993,759744,
380057,569142,450995,500151,533009,787180,796757,579408,665424,428991,486141,634709,724968,910350,755342,723301,744499,791097,
486696,650661,775896,589564,417632,460207,386577,461058,309090,401728,335814,488570,758867,599018,354581,449831,677583,583268,
452635,579431,752699,725899,457825,661835,924337,879308,792148,572914,236078,252664,248583,143285,173576,464535,323435,290071,
259483,286196,396866,459208,346403,429612,379429,317461,373328,334657,285622,316216,347387,474325,846736,421261,358587,460670,
540837,418151,473605,443747,1142146,266099,1139106,1226865,912006,544488,637168,726559,633507,783324,803464,874546,749552,490660,
644883,880869,1134430,839081,575502,778336,608858,437231,411106,666015,563343,500243,160495,290749,441946,380307,327141,528851,
386873,499151,742431,1004036,756402,854695,798836,797035,965829,672367,837390,1234139,962167,972983,1314591,1183313,847271,900132,
623507,383196,331639,259707,448397,491216,470078,535948,506772,404948,343057,429095,241972,208979,237532,289286,502020,428997,
308660,291778,588501,298147,204497,313212,504692,445722,619353,831848,511452,357941,535866,252048,403999,477594,454970,301303,551953]
size_video5=[323113,418441,382004,337817,318822,366200,363903,346976,404249,383861,369141,500281,492772,467460,412406,364336,530546,
595068,453373,400416,406242,447605,508492,416723,492336,153985,149450,221825,389137,790219,302059,288733,540456,825815,285915,
304614,354511,356853,174974,139405,344879,446520,249322,594647,540016,434577,456950,491623,284629,206793,194787,245465,201172,
543139,328951,533104,446793,532154,333255,259306,513006,294784,273182,414589,562032,426081,491024,375053,356030,434816,485000,
415484,363173,267232,217152,268349,130234,129844,244414,183197,181289,211852,230048,232458,147458,323339,286466,621150,292710,
157388,224852,330448,244658,189794,208443,272864,272767,219585,160716,199810,281265,234643,623111,905443,715137,496016,757193,
653100,866715,509267,565709,439095,458179,317013,299723,220237,265702,326004,406891,398108,396428,161148,189747,289152,438311,
391808,350823,342642,404291,312421,215746,231048,419638,401633,350467,540680,413555,274948,226952,298374,504645,399332,385815,
376112,518000,240102,380381,592007,379115,193082,217973,203101,629581,312102,266984,289355,406154,364723,444534,405512,503590,
445920,301669,381944,350196,336701,533864,849909,638562,325653,440403,227952,636997,657734,525502,518535,689114,782104,610917,
376978,476526,340219,251135,252753,267845,366877,470621,673027,231795,555250,369340,329086,269267,364173,255834,373785,469492,
336207,598436,747522,744086,688734,182335,102883,71090,251738,294267,277818,338245,291138,317642,182073,467537,572660,290618,
163813,145742,323299,269998,151414,247136,299386,379185,511734,583799,309771,794744,474007,777870,916062,639704,663002,444759,
596148,410568,350269,389119,296238,363553,277452,211307,324543,445667,365955,459618,364370,580715,438804,412688,454548,384954,
449872,351636,532810,418362,278056,331408,337389,468421,287027,339677,265929,405248,543069,387402,240196,265294,288498,506694,
574841,596509,526249,403785,389295,440901,377555,376321,360924,424678,470015,246729,206103,391925,514724,604960,481393,227540,
320553,265336,292954,332903,526009,509974,379518,402580,247420,307887,399296,490999,599427,493224,485382,474936,511692,327348,
403054,509642,370452,220414,268766,223824,273431,210187,260215,194459,282781,458374,361910,222321,254376,398627,353268,277424,
373952,485170,458908,283968,415847,594244,581598,513771,336212,123056,159415,152039,84419,96964,296357,197550,174412,150205,
163490,234384,276420,206155,251134,207262,189865,234699,190492,162133,172192,208515,294919,506806,243271,208423,266189,317494,
252397,272579,266038,626921,160573,687288,805076,516668,334312,382256,432601,382803,509989,497589,559731,472280,271315,372954,
517170,690202,505692,358051,497198,379108,274271,264254,417412,356246,329139,100180,192502,302659,248706,201499,350511,223655,
308401,454270,637270,464928,511545,498959,503850,626394,410515,466441,761200,580059,554024,831652,823388,590577,625131,404481,
242549,205265,168423,277268,309949,278503,325049,292610,262838,201999,257126,143254,124497,137758,167697,308527,256226,182915,
168765,363172,179420,124656,188561,300983,262333,396335,493415,295359,207622,306053,145571,246429,285851,275563,186508,346649]
size_video6=[122566,141690,156437,151455,131958,141687,134848,143568,169611,155749,144962,187567,189741,191607,169931,160854,236280,
279955,203736,174786,193874,187167,207081,196253,203820,58306,52004,70463,114188,248094,120126,105738,187819,288450,107224,132126,
132775,150099,72040,63120,142264,179063,113063,237672,222641,210179,206024,226841,125166,86270,76277,111752,86103,186977,124488,
195494,209856,232665,151864,114023,181418,107522,111914,191996,231947,145572,228523,165245,154746,217987,232697,199480,132247,
114355,92243,101533,44432,46959,92051,64667,69881,82966,70706,91967,52126,115033,106804,257487,110329,52198,86248,137809,98071,
59563,67579,89812,87619,65049,51508,66553,97090,69339,218786,350602,282395,196655,294150,274147,350502,229885,264751,188592,194004,
138597,129254,90055,113934,119577,163598,176947,176958,64953,63686,94317,174842,133878,119038,116797,143402,114567,79187,85619,
158887,158149,136588,211814,149475,111228,90166,110685,182666,164383,153601,193728,240841,89363,172541,249048,155912,72714,96738,
76146,210967,138516,104483,112952,166011,143486,173754,163990,184907,157542,102142,138713,132187,103266,186551,302474,233690,114527,
183684,86990,275527,303484,247110,243197,306068,333494,259092,161551,219694,163689,115479,115867,110157,165717,206413,316094,106605,
258595,167706,161871,126251,164223,106360,140197,171683,142022,226802,274115,317194,289925,80931,38396,28340,124143,139033,128434,
145168,122302,127194,68553,208520,246036,119157,62046,49114,123744,104524,56056,81724,107806,129717,178197,219082,87764,309996,
175234,291302,381763,260114,311747,197184,285496,184984,171407,180922,127859,167708,142347,108401,127627,229023,194597,231589,
188967,293808,207290,225385,222372,182989,208632,165647,262519,198122,119059,136057,151258,207737,126195,142675,116189,196934,
273298,169687,80087,89952,116953,203808,258544,276055,251654,191358,176143,185613,174725,183381,183890,208329,222059,115871,103659,
194619,263618,323870,232819,101175,148358,120409,137639,169775,286516,266060,186239,185178,111048,131835,191865,248460,308506,
263337,268120,252697,279984,174154,193877,250368,165544,97614,128553,106663,133692,98249,131557,84157,120094,191725,157144,106115,
103896,189100,153325,105096,185534,243798,242423,135512,204760,313395,292357,286477,158682,36035,72722,58693,21160,29201,149424,
93095,73211,52395,60533,84569,100012,78060,95461,63814,66318,90387,64036,46982,48426,64363,108625,183411,70708,64343,82518,105266,
82540,70162,71644,64605,51629,207652,169915,122208,106258,133986,162789,140802,190933,160253,206255,174223,70660,113933,173128,
261541,173884,115544,179952,131746,92096,84877,151907,131972,127129,27791,55798,115167,97179,63504,113963,41194,72340,149359,
210948,145277,142456,148052,171092,235134,102985,129884,278803,214629,183098,306658,352088,282790,309863,185129,100329,81350,
64536,120000,135855,104350,136764,97760,99442,67417,84531,36782,30662,33807,40182,96727,72553,43191,38019,107349,45983,30115,
45931,84315,65096,123915,152798,77492,43261,76665,36196,69589,62195,61628,33154,80528]



def get_chunk_size(quality, index):
    if ( index < 0 or index > 448 ):
        return 0
    # note that the quality and video labels are inverted (i.e., quality 8 is highest and this pertains to video1)
    sizes = {5: size_video1[index], 4: size_video2[index], 3: size_video3[index], 2: size_video4[index], 1: size_video5[index], 0: size_video6[index]}
    return sizes[quality]
class my_socketserver(SocketServer.ThreadingTCPServer):
    allow_reuse_address=True
    daemon_threads=True
    def __init__(self,server_address,RequestHandlerClass):
        SocketServer.ThreadingTCPServer.__init__(self,server_address,RequestHandlerClass)
def make_request_handler(input_dict):
    print('make req hndlr')


    class Request_Handler(BaseHTTPRequestHandler):
        def __init__(self, *args, **kwargs):#args: <socketobject>,('IP',port),<BaseHTTPServer>
            #print('init')
            self.input_dict = input_dict
            self.log_file = input_dict['log_file']
            #self.saver = input_dict['saver']
            self.s_batch = input_dict['s_batch']
            #self.a_batch = input_dict['a_batch']
            #self.r_batch = input_dict['r_batch']
            BaseHTTPRequestHandler.__init__(self, *args, **kwargs)
            #print('init base class')

########### the broken pipe error ######## not debug yet
        def handle(self):
            try:
                BaseHTTPRequestHandler.handle(self)
            except socket.error:
                pass
############################################

        def do_POST(self):
            #print('do_post')
            global Que1
            content_length = int(self.headers['Content-Length'])
            post_data = json.loads(self.rfile.read(content_length))
            #print post_data

            if ( 'pastThroughput' in post_data ):
                # @Hongzi: this is just the summary of throughput/quality at the end of the load
                # so we don't want to use this information to send back a new quality
                print "Summary: ", post_data
            elif('heartbeat' in post_data):
                if self.client_address[0] not in Que1:
                    Que1.append(self.client_address[0])
                #print('Que1',Que1[:])
                #print self.client_address
                send_data="receive hb"
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.send_header('Content-Length', len(send_data))
                self.send_header('Access-Control-Allow-Origin', "*")
                self.end_headers()
                self.wfile.write(send_data)
            else:
########## Algorithm write here! Now you get all info! #########
                global begin_time
                t = float(time.time() - begin_time)
                q = int(post_data['lastquality'])
                global Dict1,Dict2
                if self.client_address[0] in Dict1.keys():
                    tmp=Dict1[self.client_address[0]]
                    tmp.append(t)
                    Dict1[self.client_address[0]]=tmp
                    tmp=Dict2[self.client_address[0]]
                    tmp.append(q)
                    Dict2[self.client_address[0]]=tmp
                else:
                    Dict1[self.client_address[0]]=[t]
                    Dict2[self.client_address[0]]=[q]
                #print(Dict1[self.client_address[0]],Dict2[self.client_address[0]])
                global DictOnline,QueOnline
                for k in DictOnline:
                    if k not in QueOnline[:]:
                        DictOnline.pop(k)
                DictOnline[self.client_address[0]]=q
                

                # option 1. reward for just quality
                # reward = post_data['lastquality']
                # option 2. combine reward for quality and rebuffer time
                #           tune up the knob on rebuf to prevent it more
                # reward = post_data['lastquality'] - 0.1 * (post_data['RebufferTime'] - self.input_dict['last_total_rebuf'])
                # option 3. give a fixed penalty if video is stalled
                #           this can reduce the variance in reward signal
                # reward = post_data['lastquality'] - 10 * ((post_data['RebufferTime'] - self.input_dict['last_total_rebuf']) > 0)

                # option 4. use the metric in SIGCOMM MPC paper
                rebuffer_time = float(post_data['RebufferTime'] -self.input_dict['last_total_rebuf'])

                # --linear reward--
                reward = VIDEO_BIT_RATE[post_data['lastquality']] / M_IN_K \
                        - REBUF_PENALTY * rebuffer_time / M_IN_K \
                        - SMOOTH_PENALTY * np.abs(VIDEO_BIT_RATE[post_data['lastquality']] -
                                                  self.input_dict['last_bit_rate']) / M_IN_K

                # --log reward--
                # log_bit_rate = np.log(VIDEO_BIT_RATE[post_data['lastquality']] / float(VIDEO_BIT_RATE[0]))   
                # log_last_bit_rate = np.log(self.input_dict['last_bit_rate'] / float(VIDEO_BIT_RATE[0]))

                # reward = log_bit_rate \
                #          - 4.3 * rebuffer_time / M_IN_K \
                #          - SMOOTH_PENALTY * np.abs(log_bit_rate - log_last_bit_rate)

                # --hd reward--
                # reward = BITRATE_REWARD[post_data['lastquality']] \
                #         - 8 * rebuffer_time / M_IN_K - np.abs(BITRATE_REWARD[post_data['lastquality']] - BITRATE_REWARD_MAP[self.input_dict['last_bit_rate']])

                self.input_dict['last_bit_rate'] = VIDEO_BIT_RATE[post_data['lastquality']]
                self.input_dict['last_total_rebuf'] = post_data['RebufferTime']

                # retrieve previous state
                if len(self.s_batch) == 0:
                    state = [np.zeros((S_INFO, S_LEN))]
                else:
                    state = np.array(self.s_batch[-1], copy=True)

                # compute bandwidth measurement
                video_chunk_fetch_time = post_data['lastChunkFinishTime'] - post_data['lastChunkStartTime']
                video_chunk_size = post_data['lastChunkSize']

                # compute number of video chunks left
                video_chunk_remain = TOTAL_VIDEO_CHUNKS - self.input_dict['video_chunk_coount']
                self.input_dict['video_chunk_coount'] += 1

                # dequeue history record
                state = np.roll(state, -1, axis=1)

                # this should be S_INFO number of terms
                try:
                    state[0, -1] = VIDEO_BIT_RATE[post_data['lastquality']] / float(np.max(VIDEO_BIT_RATE))
                    state[1, -1] = post_data['buffer'] / BUFFER_NORM_FACTOR
                    state[2, -1] = rebuffer_time / M_IN_K
                    state[3, -1] = float(video_chunk_size) / float(video_chunk_fetch_time) / M_IN_K  # kilo byte / ms
                    state[4, -1] = np.minimum(video_chunk_remain, CHUNK_TIL_VIDEO_END_CAP) / float(CHUNK_TIL_VIDEO_END_CAP)
                    curr_error = 0 # defualt assumes that this is the first request so error is 0 since we have never predicted bandwidth
                    if ( len(past_bandwidth_ests) > 0 ):
                        curr_error  = abs(past_bandwidth_ests[-1]-state[3,-1])/float(state[3,-1])
                    past_errors.append(curr_error)
                except ZeroDivisionError:
                    # this should occur VERY rarely (1 out of 3000), should be a dash issue
                    # in this case we ignore the observation and roll back to an eariler one
                    past_errors.append(0)
                    if len(self.s_batch) == 0:
                        state = [np.zeros((S_INFO, S_LEN))]
                    else:
                        state = np.array(self.s_batch[-1], copy=True)

                # log wall_time, bit_rate, buffer_size, rebuffer_time, video_chunk_size, download_time, reward
                self.log_file.write(str(time.time()) + '\t' +
                                    str(VIDEO_BIT_RATE[post_data['lastquality']]) + '\t' +
                                    str(post_data['buffer']) + '\t' +
                                    str(rebuffer_time / M_IN_K) + '\t' +
                                    str(video_chunk_size) + '\t' +
                                    str(video_chunk_fetch_time) + '\t' +
                                    str(reward) + '\n')
                self.log_file.flush()

                # pick bitrate according to MPC           
                # first get harmonic mean of last 5 bandwidths
                past_bandwidths = state[3,-5:]
                while past_bandwidths[0] == 0.0:
                    past_bandwidths = past_bandwidths[1:]
                #if ( len(state) < 5 ):
                #    past_bandwidths = state[3,-len(state):]
                #else:
                #    past_bandwidths = state[3,-5:]
                bandwidth_sum = 0
                for past_val in past_bandwidths:
                    bandwidth_sum += (1/float(past_val))
                harmonic_bandwidth = 1.0/(bandwidth_sum/len(past_bandwidths))

                # future bandwidth prediction
                # divide by 1 + max of last 5 (or up to 5) errors
                max_error = 0
                error_pos = -5
                if ( len(past_errors) < 5 ):
                    error_pos = -len(past_errors)
                max_error = float(max(past_errors[error_pos:]))
                future_bandwidth = harmonic_bandwidth/(1+max_error)
                past_bandwidth_ests.append(harmonic_bandwidth)


                # future chunks length (try 4 if that many remaining)
                last_index = int(post_data['lastRequest'])
                future_chunk_length = MPC_FUTURE_CHUNK_COUNT
                if ( TOTAL_VIDEO_CHUNKS - last_index < 5 ):
                    future_chunk_length = TOTAL_VIDEO_CHUNKS - last_index

                # all possible combinations of 5 chunk bitrates (9^5 options)
                # iterate over list and for each, compute reward and store max reward combination
                max_reward = -100000000
                best_combo = ()
                start_buffer = float(post_data['buffer'])
                #start = time.time()
                for full_combo in CHUNK_COMBO_OPTIONS:
                    combo = full_combo[0:future_chunk_length]
                    # calculate total rebuffer time for this combination (start with start_buffer and subtract
                    # each download time and add 2 seconds in that order)
                    curr_rebuffer_time = 0
                    curr_buffer = start_buffer
                    bitrate_sum = 0
                    smoothness_diffs = 0
                    last_quality = int(post_data['lastquality'])
                    for position in range(0, len(combo)):
                        chunk_quality = combo[position]
                        index = last_index + position + 1 # e.g., if last chunk is 3, then first iter is 3+0+1=4
                        download_time = (get_chunk_size(chunk_quality, index)/1000000.)/future_bandwidth # this is MB/MB/s --> seconds
                        if ( curr_buffer < download_time ):
                            curr_rebuffer_time += (download_time - curr_buffer)
                            curr_buffer = 0
                        else:
                            curr_buffer -= download_time
                        curr_buffer += 4
                        
                        # linear reward
                        bitrate_sum += VIDEO_BIT_RATE[chunk_quality]
                        smoothness_diffs += abs(VIDEO_BIT_RATE[chunk_quality] - VIDEO_BIT_RATE[last_quality])

                        # log reward
                        # log_bit_rate = np.log(VIDEO_BIT_RATE[chunk_quality] / float(VIDEO_BIT_RATE[0]))
                        # log_last_bit_rate = np.log(VIDEO_BIT_RATE[last_quality] / float(VIDEO_BIT_RATE[0]))
                        # bitrate_sum += log_bit_rate
                        # smoothness_diffs += abs(log_bit_rate - log_last_bit_rate)

                        # hd reward
                        #bitrate_sum += BITRATE_REWARD[chunk_quality]
                        #smoothness_diffs += abs(BITRATE_REWARD[chunk_quality] - BITRATE_REWARD[last_quality])

                        last_quality = chunk_quality
                    # compute reward for this combination (one reward per 5-chunk combo)
                    # bitrates are in Mbits/s, rebuffer in seconds, and smoothness_diffs in Mbits/s
                    
                    # linear reward 
                    reward = (bitrate_sum/1000.) - (4.3*curr_rebuffer_time) - (smoothness_diffs/1000.)

                    # log reward
                    # reward = (bitrate_sum) - (4.3*curr_rebuffer_time) - (smoothness_diffs)

                    # hd reward
                    #reward = bitrate_sum - (8*curr_rebuffer_time) - (smoothness_diffs)

# Additional portion from multiagent mechanism

#                    avg_btr=0
#                    adjust_weight=0.02
#                    for (k,v) in DictOnline.items():
#                        avg_btr+=VIDEO_BIT_RATE[v]
#                    if len(DictOnline)!=0:
#                        avg_btr/=len(DictOnline)
#                    r_=combo[0]-avg_btr  # + when hd
#                    reward-=adjust_weight*r_

# #################
                    if ( reward > max_reward ):
                        max_reward = reward
                        best_combo = combo
                #print (best_combo[0],max_reward)
                # send data to html side (first chunk of best combo)
                send_data = 0 # no combo had reward better than -1000000 (ERROR) so send 0
                if ( best_combo != () ): # some combo was good
                    send_data = str(best_combo[0])#combo:(5,4,3,2,5),combo[0]:5
                end = time.time()
                #print "TOOK: " + str(end-start)

                end_of_video = False
                if ( post_data['lastRequest'] == TOTAL_VIDEO_CHUNKS ):
                    send_data = "REFRESH"
                    end_of_video = True
                    self.input_dict['last_total_rebuf'] = 0
                    self.input_dict['last_bit_rate'] = DEFAULT_QUALITY
                    self.input_dict['video_chunk_coount'] = 0
                    self.log_file.write('\n')  # so that in the log we know where video ends

                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.send_header('Content-Length', len(send_data))
                self.send_header('Access-Control-Allow-Origin', "*")
                self.end_headers()
                self.wfile.write(send_data)

                # record [state, action, reward]
                # put it here after training, notice there is a shift in reward storage

                if end_of_video:
                    self.s_batch = [np.zeros((S_INFO, S_LEN))]
                else:
                    self.s_batch.append(state)

        def do_GET(self):
            print('do_get')
            print >> sys.stderr, 'GOT REQ'
            self.send_response(200)
            #self.send_header('Cache-Control', 'Cache-Control: no-cache, no-store, must-revalidate max-age=0')
            self.send_header('Cache-Control', 'max-age=3000')
            self.send_header('Content-Length', 20)
            self.end_headers()
            self.wfile.write("console.log('here');")

        def log_message(self, format, *args):
            return

    return Request_Handler

###### onlineCheck #######
def onlineCheck(Que1_,Que2_,QueOL):
    while True:
        #print('updateQue')
        updateQue(Que1_,Que2_,QueOL)
        global Dict1,Dict2,MultiClientState,begin_time
        f=open("OLlist.json",'r')
        fcntl.flock(f,fcntl.LOCK_EX)
        try:
            MultiClientState=json.load(f)
            print(MultiClientState)
        except:
            MultiClientState={}
        for ip in MultiClientState.keys():
            if int(time.time())-MultiClientState[ip][0]-10>0:
                MultiClientState.pop(ip)
        tmp={}
        try:
            tmp[QueOL[:][0]]=[time.time(),max(max(Dict2.values()))]
        except:
            pass
        MultiClientState.update(tmp)
        print(MultiClientState)
        fcntl.flock(f,fcntl.LOCK_UN)
        f.close()
        f=open("OLlist.json",'w')
        fcntl.flock(f,fcntl.LOCK_EX)
        json.dump(MultiClientState,f)
        fcntl.flock(f,fcntl.LOCK_UN)
        f.close()
        plot(Dict1,Dict2)
        time.sleep(5)
def updateQue(Que1_,Que2_,QueOL):
    #print('_Que1',Que1_[:])
    #print('_Que2',Que2_[:])
    #print('_QueOnline',QueOL[:])
    QueOL[:]=Que1_[:]+[item for item in Que2_[:] if item not in Que1_[:]]
    Que2_[:]=copy.copy(Que1_[:])
    Que1_[:]=[]
    #print('Que1_',Que1_[:])
    #print('Que2_',Que2_[:])
    print('QueOnline_',QueOL[:])
##########################
###########plot###########
def plot(Dictt,Dictq):
    color_ = ['black', 'red', 'blue', 'green', 'gold', 'm']
    c=0
    for k in Dictt.keys():
        plt.plot(Dictt[k], Dictq[k], color=color_[c%6])
        #print(Dictt[k],Dictq[k])
        plt.scatter(Dictt[k], Dictq[k], color=color_[c%6])
        plt.title("MPC_1")
        plt.axis([-1,max(Dictt[k])*1.1,0,6])
        c=c+1
    plt.pause(1)

##########################

def run(server_class=HTTPServer, port=8333, log_file_path=LOG_FILE):#port=8333 also needs to change in dash.all.min.js

    np.random.seed(RANDOM_SEED)

    if not os.path.exists(SUMMARY_DIR):
        os.makedirs(SUMMARY_DIR)

    # make chunk combination options
    for combo in itertools.product([0,1,2,3,4,5], repeat=5):#produce 6^5 samples like (5,5,3,3,1)
        CHUNK_COMBO_OPTIONS.append(combo)

    with open(log_file_path, 'wb') as log_file:

        s_batch = [np.zeros((S_INFO, S_LEN))]

        last_bit_rate = DEFAULT_QUALITY
        last_total_rebuf = 0
        # need this storage, because observation only contains total rebuffering time
        # we compute the difference to get

        video_chunk_count = 0

        input_dict = {'log_file': log_file,
                      'last_bit_rate': last_bit_rate,
                      'last_total_rebuf': last_total_rebuf,
                      'video_chunk_coount': video_chunk_count,
                      's_batch': s_batch}

        # interface to abr_rl server
        handler_class = make_request_handler(input_dict=input_dict)

        server_address = ('', port)#'localhost'
        #httpd = server_class(server_address, handler_class)
	httpd = my_socketserver(server_address, handler_class)
        print 'Listening on port ' + str(port)
####### onlineCheck ######
        global Que1
        global Que2
        global QueOnline
        p = multiprocessing.Process(target=onlineCheck,args=(Que1,Que2,QueOnline))
        p.start()
        p.deamon = True
##########################
        httpd.serve_forever()


def main():
    if len(sys.argv) == 2:
        trace_file = sys.argv[1]
        run(log_file_path=LOG_FILE + '_robustMPC_' + trace_file)
    else:
        run()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print "Keyboard interrupted."
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
